#!/usr/bin/python3
# SPDX-License-Identifier:Â MIT
# Copyright (c) 2023, Gene C
"""
 Dual Root Tool
  Identify which <esp> was used to boot the currently running system.

  - identify which <esp> was used to boot current system
  - support bind mounting this <esp> onto /boot
  - support rsyncing this onto the alternate <esp>

 Required
   python (> 3.9), efibootmgr, mount, rsync

 Should a low level tool be in python? Probably not, but it gets a working tool done
 reasonably safely and quickly.  This is far too complex for a bash script, but we
 should probably make a statically linked C++ or C version at some point.

 But for now this works.

 GC 2023
"""
import os
import subprocess
import argparse

# ----------------------------------------------------------------------------------------------
# Class Support functions
#
def run_prog(pargs,input_str=None,stdout=subprocess.PIPE,stderr=subprocess.PIPE):
    """
    run external program
    """
    if not pargs:
        return [0, None, None]

    bstring = None
    if input_str:
        bstring = bytearray(input_str,'utf-8')

    ret = subprocess.run(pargs, input=bstring, stdout=stdout, stderr=stderr, check=False)
    retc = ret.returncode
    output = None
    errors = None
    if ret.stdout :
        output = str(ret.stdout, 'utf-8', errors='ignore')
    if ret.stderr :
        errors = str(ret.stderr, 'utf-8', errors='ignore')
    return [retc, output, errors]

def device_to_uuid_mount(dev):
    """
    Look up the UUID and mount point for /dev/xxx
     return list of mounts
    Support method for Esp class
    """
    if not dev:
        return None
    pargs = ['/usr/bin/lsblk', '-no', 'UUID,MOUNTPOINTS', dev]
    [retc, result, _err] = run_prog(pargs)

    if retc != 0:
        print(f'Failed to find uuid of {dev}')
        return None

    uuid = None

    result = result.splitlines()

    mounts = []
    for item in result:
        item = item.split()
        if len(item) > 1:
            uuid = item[0]
            mount = item[1]
        else:
            mount = item[0]
        mounts.append(mount)
    return (uuid, mounts)

def os_scandir(tdir):
    """
    wrapper around scandir with exception hadnling
    """
    scan = None
    if os.path.exists(tdir) and os.path.isdir(tdir) :
        try:
            scan = os.scandir(tdir)
        except OSError as _error:
            scan = None
    return scan

# ----------------------------------------------------------------------------------------------

class Esp:
    """
    Info for one <esp>
    """
    # pylint: disable=R0903
    def __init__(self):
        self.partuuid = None
        self.uuid = None
        self.mount = None
        self.mount_other = []       # handle esp mounted other than /efi0, /efi1 etc
        self.dev = None
        self.mount_list = []

        self.uuid_and_mounts()

    def uuid_and_mounts(self):
        """
        Find partuuid and uuid of currently booted esp
        Run efibootmgr to find it.
        """
        # pylint: disable=R0912
        pargs = ['/usr/bin/efibootmgr']
        [retc, stdout, _stderr] = run_prog(pargs)
        if retc != 0:
            print('Failed to run efibootmgr')
            return

        #
        # Find current bootnum
        #
        stdout = stdout.splitlines()
        bootnum = None
        for row in stdout:
            if row.startswith('BootCurrent:'):
                bootnum = row.split()[1]
                break
        if not bootnum:
            print('Failed to find current bootnum')
            return

        #
        # Find current boot info from bootnu
        #
        thisboot = f'Boot{bootnum}'
        bootinfo = None
        for row in stdout:
            if row.startswith(thisboot):
                bootinfo = row
                break
        if not bootinfo:
            print('Failed to find boot line with partuuid')
            return

        #
        # Extract the partuuid
        #
        # Line to parse: Bootxxx* <text> HD(n,GPT,partuuid,xxx,..)
        #
        partuuid = None
        lsplit = bootinfo.split(',')
        if len(lsplit) >= 2:
            partuuid = lsplit[2]

        if not partuuid:
            print('Failed to find partuuid from boot info line')
        self.partuuid = partuuid

        #
        # Get UUID and all mounts of this UUID
        #
        ppath = f'/dev/disk/by-partuuid/{self.partuuid}'
        if os.path.islink(ppath):
            dev = os.readlink(ppath)
            dev = os.path.basename(dev)
            dev = f'/dev/{dev}'
            self.dev = dev
            (self.uuid, self.mount_list) = device_to_uuid_mount(dev)

        #
        # Identify mount ~ /efiN
        #
        self.mount_other = []
        for mount in self.mount_list:
            if len(mount) > 4 and mount[0:4] == '/efi':
                self.mount = mount
            else:
                self.mount_other.append(mount)

class EspInfo:
    """
    Identify esp info (UUID, mount points etc
     Support bind mounting current <esp> onto efi_mount (/boot)
     Support rsync current to alternate esp
    """
    def __init__(self, conf):
        #
        # esp is the currently booted esp.
        # Alternate esp's are listed in esp_alt
        #
        self.test = conf['test']
        self.esp = Esp()
        self.esp_alt = []

        self.efi_mount = conf['efi_mount']
        self.efi_mount_uuid = None
        self.efi_mounted = False
        self.efi_uuid_correct = False
        self.euid = os.geteuid()
        self.dual_root_mount_list = []

        self.efi_mount_uuid = self.find_efi_mount_uuid(self.efi_mount)
        self.is_efi_mounted()

        self.efi_other = []     # list of all mounts /efiN

    def find_efi_mount_uuid(self, efi_mount):
        """
        Find the device UUID mounted at efi_mount
        """
        if not efi_mount:
            return None

        pargs = ['/usr/bin/lsblk', '-lno', 'UUID,MOUNTPOINTS']
        [retc, result, _err] = run_prog(pargs)

        if retc != 0:
            print('Failed to find any uuids')
            return None

        result = result.splitlines()

        efi_mount_uuid = None
        for item in result:
            items = item.split()
            if len(items) > 1:
                (this_uuid, this_mount) = items
                if this_mount == efi_mount:
                    efi_mount_uuid = this_uuid
                    break

        return efi_mount_uuid

    def is_efi_mounted(self):
        """
        Check if efi_mount (aka /boot) mounted and if UUID we want
        default efi_mount = '/boot'
        """
        self.efi_mounted = False
        self.efi_uuid_correct = False
        if self.efi_mount in self.esp.mount_list:
            self.efi_mounted = True
            if self.efi_mount_uuid == self.esp.uuid:
                self.efi_uuid_correct = True

    def print_info(self):
        """ print useful info """
        print(f'Booted esp : {self.esp.dev} : {self.esp.mount_list} : {self.esp.uuid}')
        #print(f'Boot mount : {self.efi_mount} : {self.efi_mount_uuid}')

    def bind_mount_efi(self):
        """
        Bind mount current <esp> from esp.mount onto efi_mount (/boot)
            esp_mount typically /efi0 or /efi
            efi_mount typically /boot
            check that efi_mount (/boot) is not mounted already
        """
        if self.efi_mounted:
            if self.efi_uuid_correct:
                print(f'{self.esp.uuid} {self.esp.mount} already mounted at {self.efi_mount}')
            else:
                print(f'{self.efi_mount} mounted but uuid wrong - should be {self.esp.uuid}')
        elif not self.esp.mount:
            print('Not dual root, bind mount skipped: esp not mounted at /efi0,/efi1 ...')
        else:
            print(f'mount --bind {self.esp.mount} {self.efi_mount}')
            if self.euid == 0 and not self.test:
                pargs = ['/usr/bin/mount', '--bind', self.esp.mount, self.efi_mount]
                [retc, _out, err] = run_prog(pargs)
                if retc != 0:
                    print(f'Mount failed: {err}')
            else:
                print('Must be root to use bind mount')

    def dual_root_mounts(self):
        """
        Make a list of all the mounts names /efi<N>
         - Should we exclude booted /efi<n>
        """
        self.dual_root_mount_list = []
        #booted_efi = self.esp.mount

        root_scan = os_scandir('/')
        if not root_scan:
            return

        for item in root_scan:
            path = item.path
            if path.startswith('/efi') and len(path) > 4:
                self.dual_root_mount_list.append(path)


    def sync_alt_efi(self):
        """
        Sync the current booted esp to other esps
        If /efi0 is current then sync
          - /efi0/* -> /efiN for N != 0
        """
        opts = []
        if self.test:
            opts += ['-nv']
        opts += ['-axHAX', '--exclude=/lost+found/', '--delete']
        rsync = ['/usr/bin/rsync'] + opts

        self.dual_root_mounts()
        current_efi = self.esp.mount
        all_dual_mounts = self.dual_root_mount_list

        if not all_dual_mounts:
            print('Not dual root (/afi<n> not found) -  nothing to sync')
            return

        if len(all_dual_mounts) == 1:
            this_efi = all_dual_mounts[0]
            print(f'Only 1 dual root esp found ({this_efi}) -  nothing to sync')
            return

        for this_efi in all_dual_mounts:
            if this_efi != current_efi:
                pargs = rsync + [f'{current_efi}/', f'{this_efi}/']
                cmd = ' '.join(pargs)
                print(cmd)

                [retc, out, err] = run_prog(pargs)
                if retc != 0:
                    print(f'rsync failed: {current_efi}/ -> {this_efi}/')
                    print(err)
                elif self.test and out:
                    print(out)

def parse_args():
    """
    Command line requests
    """
    desc = 'dual-root-tool : dual <esp> management tool'

    bind = False
    sync = False
    test = False
    efi_mount = '/boot'

    par = argparse.ArgumentParser(description=desc)
    par.add_argument('-b', '--bind', action='store_true', help='Bind mount active esp to efi mount')
    par.add_argument('-s', '--sync', action='store_true', help='Sync active efi to alternate')
    par.add_argument('-t', '--test', action='store_true', help='Test mode')
    par.add_argument('efi_mount', nargs='?', default=efi_mount,
                     help=f'Where to bind mount active esp ({efi_mount})')
    parsed = par.parse_args()
    if parsed:
        if parsed.bind:
            bind = parsed.bind
        if parsed.sync:
            sync = parsed.sync
        if parsed.test:
            test = parsed.test

        efi_mount = parsed.efi_mount

    conf = {
            'bind'   : bind,
            'sync'   : sync,
            'test'   : test,
            'efi_mount' : efi_mount,
            }

    return conf

#import pdb
def main():
    """
    Tool to :
        - identify currently booted <esp>
        - bind mount currently booted <esp> onto /boot
        - sync currently booted <esp> on to the other <esp>
    Arhg :
         no arguments : print out information about currenntly booted efi
         -b           : bind mount currently booted <esp> onto "mount" - default is /boot
         -s           : sync currentnly booted <esp> to the other on
         -h           : help
         efi_mount     : where to mount the active esp - default is /boot
    """
    #pdb.set_trace()
    conf = parse_args()

    esp = EspInfo(conf)
    esp.print_info()

    if conf["bind"]:
        esp.bind_mount_efi()
    if conf["sync"]:
        esp.sync_alt_efi()

if __name__ == '__main__':
    main()
